// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addUserToGroup = `-- name: AddUserToGroup :exec
insert into user_group (user_id, group_id)
values ($1, $2)
`

type AddUserToGroupParams struct {
	UserID  int64
	GroupID int64
}

func (q *Queries) AddUserToGroup(ctx context.Context, arg AddUserToGroupParams) error {
	_, err := q.db.Exec(ctx, addUserToGroup, arg.UserID, arg.GroupID)
	return err
}

const createExpense = `-- name: CreateExpense :one
insert into expenses (group_id, amount, currency_id, expense_at)
values ($1, $2, $3, $4)
returning id, group_id, amount, currency_id, expense_at, created_at, is_deleted
`

type CreateExpenseParams struct {
	GroupID    int64
	Amount     pgtype.Numeric
	CurrencyID int64
	ExpenseAt  pgtype.Timestamp
}

func (q *Queries) CreateExpense(ctx context.Context, arg CreateExpenseParams) (Expense, error) {
	row := q.db.QueryRow(ctx, createExpense,
		arg.GroupID,
		arg.Amount,
		arg.CurrencyID,
		arg.ExpenseAt,
	)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Amount,
		&i.CurrencyID,
		&i.ExpenseAt,
		&i.CreatedAt,
		&i.IsDeleted,
	)
	return i, err
}

const createExpensePayer = `-- name: CreateExpensePayer :one
insert into expense_payers (expense_id, user_id, amount)
values ($1, $2, $3)
returning id, expense_id, user_id, amount, created_at
`

type CreateExpensePayerParams struct {
	ExpenseID int64
	UserID    int64
	Amount    pgtype.Numeric
}

func (q *Queries) CreateExpensePayer(ctx context.Context, arg CreateExpensePayerParams) (ExpensePayer, error) {
	row := q.db.QueryRow(ctx, createExpensePayer, arg.ExpenseID, arg.UserID, arg.Amount)
	var i ExpensePayer
	err := row.Scan(
		&i.ID,
		&i.ExpenseID,
		&i.UserID,
		&i.Amount,
		&i.CreatedAt,
	)
	return i, err
}

const createExpenseShare = `-- name: CreateExpenseShare :one
insert into expense_shares (expense_id, user_id, amount)
values ($1, $2, $3)
returning id, expense_id, user_id, amount, created_at
`

type CreateExpenseShareParams struct {
	ExpenseID int64
	UserID    int64
	Amount    pgtype.Numeric
}

func (q *Queries) CreateExpenseShare(ctx context.Context, arg CreateExpenseShareParams) (ExpenseShare, error) {
	row := q.db.QueryRow(ctx, createExpenseShare, arg.ExpenseID, arg.UserID, arg.Amount)
	var i ExpenseShare
	err := row.Scan(
		&i.ID,
		&i.ExpenseID,
		&i.UserID,
		&i.Amount,
		&i.CreatedAt,
	)
	return i, err
}

const createGroup = `-- name: CreateGroup :one
insert into groups (name)
values ($1)
returning id, name, created_at, is_deleted
`

func (q *Queries) CreateGroup(ctx context.Context, name string) (Group, error) {
	row := q.db.QueryRow(ctx, createGroup, name)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.IsDeleted,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
insert into users (username, email, password)
values ($1, $2, $3)
returning id, username, email, password, created_at, is_deleted
`

type CreateUserParams struct {
	Username string
	Email    string
	Password string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Username, arg.Email, arg.Password)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
		&i.IsDeleted,
	)
	return i, err
}

const deleteExpense = `-- name: DeleteExpense :exec
update expenses
set is_deleted = true
where id = $1
`

func (q *Queries) DeleteExpense(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteExpense, id)
	return err
}

const getCurrencies = `-- name: GetCurrencies :many
select id, code, name, symbol, created_at, is_deleted
from currencies
where is_deleted = false
`

func (q *Queries) GetCurrencies(ctx context.Context) ([]Currency, error) {
	rows, err := q.db.Query(ctx, getCurrencies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Currency
	for rows.Next() {
		var i Currency
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Symbol,
			&i.CreatedAt,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrenciesByIds = `-- name: GetCurrenciesByIds :many
select id, code, name, symbol, created_at, is_deleted
from currencies
where is_deleted = false
  and id = ANY ($1::bigint[])
`

func (q *Queries) GetCurrenciesByIds(ctx context.Context, dollar_1 []int64) ([]Currency, error) {
	rows, err := q.db.Query(ctx, getCurrenciesByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Currency
	for rows.Next() {
		var i Currency
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Symbol,
			&i.CreatedAt,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpense = `-- name: GetExpense :one
select id, group_id, amount, currency_id, expense_at, created_at, is_deleted
from expenses
where id = $1
  and is_deleted = false
`

func (q *Queries) GetExpense(ctx context.Context, id int64) (Expense, error) {
	row := q.db.QueryRow(ctx, getExpense, id)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Amount,
		&i.CurrencyID,
		&i.ExpenseAt,
		&i.CreatedAt,
		&i.IsDeleted,
	)
	return i, err
}

const getExpenses = `-- name: GetExpenses :many
select id, group_id, amount, currency_id, expense_at, created_at, is_deleted
from expenses
where group_id = $1
  and is_deleted = false
order by expense_at desc
`

func (q *Queries) GetExpenses(ctx context.Context, groupID int64) ([]Expense, error) {
	rows, err := q.db.Query(ctx, getExpenses, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Amount,
			&i.CurrencyID,
			&i.ExpenseAt,
			&i.CreatedAt,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpensesPayers = `-- name: GetExpensesPayers :many
SELECT id, expense_id, user_id, amount, created_at
FROM expense_payers
WHERE expense_id = ANY ($1::bigint[])
`

func (q *Queries) GetExpensesPayers(ctx context.Context, dollar_1 []int64) ([]ExpensePayer, error) {
	rows, err := q.db.Query(ctx, getExpensesPayers, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExpensePayer
	for rows.Next() {
		var i ExpensePayer
		if err := rows.Scan(
			&i.ID,
			&i.ExpenseID,
			&i.UserID,
			&i.Amount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpensesShares = `-- name: GetExpensesShares :many
SELECT id, expense_id, user_id, amount, created_at
FROM expense_shares
WHERE expense_id = ANY ($1::bigint[])
`

func (q *Queries) GetExpensesShares(ctx context.Context, dollar_1 []int64) ([]ExpenseShare, error) {
	rows, err := q.db.Query(ctx, getExpensesShares, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExpenseShare
	for rows.Next() {
		var i ExpenseShare
		if err := rows.Scan(
			&i.ID,
			&i.ExpenseID,
			&i.UserID,
			&i.Amount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroup = `-- name: GetGroup :one
select id, name, created_at, is_deleted
from groups
where id = $1
  and is_deleted = false
`

func (q *Queries) GetGroup(ctx context.Context, id int64) (Group, error) {
	row := q.db.QueryRow(ctx, getGroup, id)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.IsDeleted,
	)
	return i, err
}

const getGroupMembers = `-- name: GetGroupMembers :many
select u.id, u.username, u.email, u.password, u.created_at, u.is_deleted
from users u
         join user_group ug on u.id = ug.user_id
where ug.group_id = $1
  and u.is_deleted = false
  and ug.is_deleted = false
`

func (q *Queries) GetGroupMembers(ctx context.Context, groupID int64) ([]User, error) {
	rows, err := q.db.Query(ctx, getGroupMembers, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.CreatedAt,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupsByUser = `-- name: GetGroupsByUser :many
select g.id, g.name, g.created_at, g.is_deleted
from groups g
         join user_group ug on g.id = ug.group_id
         join user u on ug.user_id = u.id
where ug.user_id = $1
  and g.is_deleted = false
  and ug.is_deleted = false
  and u.is_deleted = false
`

func (q *Queries) GetGroupsByUser(ctx context.Context, userID int64) ([]Group, error) {
	rows, err := q.db.Query(ctx, getGroupsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
select id, username, email, password, created_at, is_deleted
from users
where email = $1
  and is_deleted = false
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
		&i.IsDeleted,
	)
	return i, err
}

const getUsersByIds = `-- name: GetUsersByIds :many
select id, username, email, password, created_at, is_deleted
from users
where id = ANY ($1::bigint[])
    and is_deleted = false
`

func (q *Queries) GetUsersByIds(ctx context.Context, dollar_1 []int64) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.CreatedAt,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
