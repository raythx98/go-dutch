package graphql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"errors"
	"slices"
	"strconv"
	"time"

	pgx "github.com/jackc/pgx/v5"
	"github.com/raythx98/go-dutch/graphql/model"
	"github.com/raythx98/go-dutch/sqlc/db"
	"github.com/raythx98/go-dutch/tools/pghelper"
	"github.com/raythx98/go-dutch/tools/randstr"
	"github.com/raythx98/gohelpme/errorhelper"
	"github.com/raythx98/gohelpme/tool/logger"
	"github.com/shopspring/decimal"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, email string, password string, username string) (*model.User, error) {
	_, err := r.DbQuery.GetUserByEmail(ctx, email)
	if err == nil {
		return nil, errorhelper.NewAppError(EmailAlreadyRegistered, Messages[EmailAlreadyRegistered], err)
	}
	if !errors.Is(err, pgx.ErrNoRows) {
		return nil, err
	}

	_, err = r.DbQuery.GetUserByUsername(ctx, username)
	if err == nil {
		return nil, errorhelper.NewAppError(UsernameAlreadyRegistered, Messages[UsernameAlreadyRegistered], err)
	}
	if !errors.Is(err, pgx.ErrNoRows) {
		return nil, err
	}

	encodedHashedPassword, err := r.Crypto.GenerateFromPassword(password)
	if err != nil {
		return nil, err
	}

	user, err := r.DbQuery.CreateUser(ctx, db.CreateUserParams{
		Username: username,
		Email:    email,
		Password: encodedHashedPassword,
	})
	if err != nil {
		return nil, err
	}

	accessToken, err := r.Jwt.NewAccessToken(strconv.FormatInt(user.ID, 10))
	if err != nil {
		return nil, err
	}

	response := toUserModel(user)
	response.Token = accessToken

	return response, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.User, error) {
	user, err := r.DbQuery.GetUserByEmail(ctx, email)
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, errorhelper.NewAppError(EmailNotRegistered, Messages[EmailNotRegistered], err)
	}
	if err != nil {
		return nil, err
	}

	authenticated, err := r.Crypto.ComparePasswordAndHash(password, user.Password)
	if err != nil {
		return nil, err
	}

	if !authenticated {
		return nil, errorhelper.NewAppError(InvalidCredentials, Messages[InvalidCredentials], err)
	}

	accessToken, err := r.Jwt.NewAccessToken(strconv.FormatInt(user.ID, 10))
	if err != nil {
		return nil, err
	}

	response := toUserModel(user)
	response.Token = accessToken

	return response, nil
}

// JoinGroup is the resolver for the joinGroup field.
func (r *mutationResolver) JoinGroup(ctx context.Context, inviteCode string) (*model.Group, error) {
	group, err := r.DbQuery.GetGroupByInviteToken(ctx, inviteCode)
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, errorhelper.NewAppError(InvalidInviteCode, Messages[InvalidInviteCode], err)
	}
	if err != nil {
		return nil, err
	}

	userId := getActionTaker(ctx)

	err = r.DbQuery.AddUserToGroup(ctx, db.AddUserToGroupParams{
		UserID:  userId,
		GroupID: group.ID,
	})
	if err != nil {
		return nil, err
	}

	return toGroupModel(group), nil
}

// AddGroup is the resolver for the addGroup field.
func (r *mutationResolver) AddGroup(ctx context.Context, name string) (*model.Group, error) {
	tx, err := r.Db.Pool().Begin(ctx)
	if err != nil {
		return nil, err
	}

	defer func(tx pgx.Tx, ctx context.Context) {
		if err := tx.Rollback(ctx); err != nil {
			r.Log.Error(ctx, "failed to rollback transaction", logger.WithError(err))
		}
	}(tx, ctx)

	qtx := r.DbQuery.WithTx(tx)

	group, err := qtx.CreateGroup(ctx, db.CreateGroupParams{
		Name:        name,
		InviteToken: randstr.Generate(10),
	})
	if err != nil {
		return nil, err
	}

	err = qtx.AddUserToGroup(ctx, db.AddUserToGroupParams{
		UserID:  getActionTaker(ctx),
		GroupID: group.ID,
	})
	if err != nil {
		return nil, err
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, err
	}

	return toGroupModel(group), nil
}

// DeleteGroup is the resolver for the deleteGroup field.
func (r *mutationResolver) DeleteGroup(ctx context.Context, groupID int64) (bool, error) {
	userId := getActionTaker(ctx)

	_, err := checkIsGroupMember(ctx, r.DbQuery, groupID, userId)
	if err != nil {
		return false, err
	}

	err = r.DbQuery.DeleteGroup(ctx, groupID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// AddMember is the resolver for the addMember field.
func (r *mutationResolver) AddMember(ctx context.Context, groupID int64, identifier string) (*model.Group, error) {
	userId := getActionTaker(ctx)

	group, err := r.DbQuery.GetGroup(ctx, groupID)
	if err != nil {
		return nil, err
	}

	_, err = checkIsGroupMember(ctx, r.DbQuery, groupID, userId)
	if err != nil {
		return nil, err
	}

	user, err := r.DbQuery.GetUserByUsernameOrEmail(ctx, identifier)
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, errorhelper.NewAppError(UserDoesNotExist, Messages[UserDoesNotExist], err)
	}
	if err != nil {
		return nil, err
	}

	err = r.DbQuery.AddUserToGroup(ctx, db.AddUserToGroupParams{
		UserID:  user.ID,
		GroupID: groupID,
	})
	if err != nil {
		return nil, err
	}

	return toGroupModel(group), nil
}

// AddRepayment is the resolver for the addRepayment field.
func (r *mutationResolver) AddRepayment(ctx context.Context, groupID int64, input model.RepaymentInput) (*model.Expense, error) {
	_, err := checkIsGroupMember(ctx, r.DbQuery, groupID, getActionTaker(ctx))
	if err != nil {
		return nil, err
	}

	currency, err := getCurrency(ctx, r.DbQuery, err, input.CurrencyID)
	if err != nil {
		return nil, err
	}

	users, err := r.DbQuery.GetUsersByIds(ctx, []int64{input.Debtor, input.Creditor})
	if err != nil {
		return nil, err
	}
	if len(users) != 2 {
		return nil, errorhelper.NewAppError(UserDoesNotExist, Messages[UserDoesNotExist], nil)
	}

	userMap := make(map[int64]db.User)
	for _, user := range users {
		userMap[user.ID] = user
	}

	tx, err := r.Db.Pool().Begin(ctx)
	if err != nil {
		return nil, err
	}

	defer func(tx pgx.Tx, ctx context.Context) {
		if err := tx.Rollback(ctx); err != nil {
			r.Log.Error(ctx, "failed to rollback transaction", logger.WithError(err))
		}
	}(tx, ctx)

	qtx := r.DbQuery.WithTx(tx)

	now := time.Now()

	expense, err := qtx.CreateExpense(ctx, db.CreateExpenseParams{
		GroupID:     groupID,
		Type:        expenseTypeFromString(input.Type),
		Name:        input.Name,
		Description: input.Description,
		Amount:      pghelper.FromDecimal(input.Amount),
		CurrencyID:  input.CurrencyID,
		ExpenseAt:   pghelper.Time(&input.ExpenseAt),
		CreatedAt:   pghelper.Time(&now),
	})
	if err != nil {
		return nil, err
	}

	expensePayer, err := qtx.CreateExpensePayer(ctx, db.CreateExpensePayerParams{
		ExpenseID: expense.ID,
		UserID:    input.Creditor,
		Amount:    pghelper.FromDecimal(input.Amount),
	})
	if err != nil {
		return nil, err
	}

	expenseSharer, err := qtx.CreateExpenseShare(ctx, db.CreateExpenseShareParams{
		ExpenseID: expense.ID,
		UserID:    input.Debtor,
		Amount:    pghelper.FromDecimal(input.Amount),
	})
	if err != nil {
		return nil, err
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, err
	}

	return &model.Expense{
		ID:          expense.ID,
		Type:        expenseTypeString(expense.Type),
		Name:        expense.Name,
		Description: expense.Description,
		Amount:      pghelper.Decimal(expense.Amount),
		Currency:    toCurrencyModel(currency),
		ExpenseAt:   expense.ExpenseAt.Time,
		Payers: []*model.Share{
			{
				User:   toUserModel(userMap[expensePayer.UserID]),
				Amount: pghelper.Decimal(expensePayer.Amount),
			},
		},
		Shares: []*model.Share{
			{
				User:   toUserModel(userMap[expenseSharer.UserID]),
				Amount: pghelper.Decimal(expenseSharer.Amount),
			},
		},
	}, nil
}

// AddExpense is the resolver for the addExpense field.
func (r *mutationResolver) AddExpense(ctx context.Context, groupID int64, input model.ExpenseInput) (*model.Expense, error) {
	_, err := checkIsGroupMember(ctx, r.DbQuery, groupID, getActionTaker(ctx))
	if err != nil {
		return nil, err
	}

	currency, err := getCurrency(ctx, r.DbQuery, err, input.CurrencyID)
	if err != nil {
		return nil, err
	}

	usersMap, err := fetchUsersMap(ctx, r.DbQuery, input)
	if err != nil {
		return nil, err
	}

	tx, err := r.Db.Pool().Begin(ctx)
	if err != nil {
		return nil, err
	}

	defer func(tx pgx.Tx, ctx context.Context) {
		if err := tx.Rollback(ctx); err != nil {
			r.Log.Error(ctx, "failed to rollback transaction", logger.WithError(err))
		}
	}(tx, ctx)

	qtx := r.DbQuery.WithTx(tx)

	now := time.Now()
	response, err := createExpense(ctx, qtx, groupID, input, currency, usersMap, pghelper.Time(&now))
	if err != nil {
		return nil, err
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, err
	}

	return response, nil
}

// EditExpense is the resolver for the editExpense field.
func (r *mutationResolver) EditExpense(ctx context.Context, expenseID int64, input model.ExpenseInput) (*model.Expense, error) {
	userId := getActionTaker(ctx)

	existingExpense, err := r.DbQuery.GetExpense(ctx, expenseID)
	if err != nil {
		return nil, err
	}

	_, err = checkIsGroupMember(ctx, r.DbQuery, existingExpense.GroupID, userId)
	if err != nil {
		return nil, err
	}

	currency, err := getCurrency(ctx, r.DbQuery, err, input.CurrencyID)
	if err != nil {
		return nil, err
	}

	usersMap, err := fetchUsersMap(ctx, r.DbQuery, input)
	if err != nil {
		return nil, err
	}

	tx, err := r.Db.Pool().Begin(ctx)
	if err != nil {
		return nil, err
	}

	defer func(tx pgx.Tx, ctx context.Context) {
		if err := tx.Rollback(ctx); err != nil {
			r.Log.Error(ctx, "failed to rollback transaction", logger.WithError(err))
		}
	}(tx, ctx)

	qtx := r.DbQuery.WithTx(tx)

	response, err := createExpense(ctx, qtx, existingExpense.GroupID, input, currency, usersMap, existingExpense.CreatedAt)
	if err != nil {
		return nil, err
	}

	if err := qtx.DeleteExpense(ctx, expenseID); err != nil {
		return nil, err
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, err
	}

	return response, nil
}

// DeleteExpense is the resolver for the deleteExpense field.
func (r *mutationResolver) DeleteExpense(ctx context.Context, expenseID int64) (bool, error) {
	userId := getActionTaker(ctx)

	expense, err := r.DbQuery.GetExpense(ctx, expenseID)
	if err != nil {
		return false, err
	}

	_, err = checkIsGroupMember(ctx, r.DbQuery, expense.GroupID, userId)
	if err != nil {
		return false, err
	}

	if err := r.DbQuery.DeleteExpense(ctx, expenseID); err != nil {
		return false, err
	}

	return true, nil
}

// PreviewGroup is the resolver for the previewGroup field.
func (r *queryResolver) PreviewGroup(ctx context.Context, inviteCode string) (*model.RedactedGroup, error) {
	group, err := r.DbQuery.GetGroupByInviteToken(ctx, inviteCode)
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, errorhelper.NewAppError(InvalidInviteCode, Messages[InvalidInviteCode], err)
	}
	if err != nil {
		return nil, err
	}

	members, err := r.DbQuery.GetGroupMembers(ctx, group.ID)
	if err != nil {
		return nil, err
	}

	response := &model.RedactedGroup{
		Name:    group.Name,
		Members: make([]*model.User, 0),
	}

	for _, member := range members {
		response.Members = append(response.Members, toUserModel(member))
	}

	return response, nil
}

// Groups is the resolver for the groups field.
func (r *queryResolver) Groups(ctx context.Context) ([]*model.Group, error) {
	userId := getActionTaker(ctx)

	groups, err := r.DbQuery.GetGroupsByUser(ctx, userId)
	if err != nil {
		return nil, err
	}

	response := make([]*model.Group, 0)
	for _, group := range groups {
		response = append(response, toGroupModel(group))
	}

	return response, nil
}

// Expenses is the resolver for the expenses field.
func (r *queryResolver) Expenses(ctx context.Context, groupID int64) (*model.ExpenseSummary, error) {
	userId := getActionTaker(ctx)

	_, err := checkIsGroupMember(ctx, r.DbQuery, groupID, userId)

	expenses, err := r.DbQuery.GetExpenses(ctx, groupID)
	if err != nil {
		return nil, err
	}

	expenseIds := make([]int64, 0)
	currencyIds := make([]int64, 0)
	for _, expense := range expenses {
		expenseIds = append(expenseIds, expense.ID)
		if !slices.Contains(currencyIds, expense.CurrencyID) {
			currencyIds = append(currencyIds, expense.CurrencyID)
		}
	}

	payers, err := r.DbQuery.GetExpensesPayers(ctx, expenseIds)
	if err != nil {
		return nil, err
	}

	shares, err := r.DbQuery.GetExpensesShares(ctx, expenseIds)
	if err != nil {
		return nil, err
	}

	currencies, err := r.DbQuery.GetCurrenciesByIds(ctx, currencyIds)
	if err != nil {
		return nil, err
	}
	if len(currencies) != len(currencyIds) {
		return nil, errorhelper.NewAppError(CurrencyNotSupported, Messages[CurrencyNotSupported], nil)
	}

	userIds := make([]int64, 0)
	for _, p := range payers {
		if !slices.Contains(userIds, p.UserID) {
			userIds = append(userIds, p.UserID)
		}
	}
	for _, s := range shares {
		if !slices.Contains(userIds, s.UserID) {
			userIds = append(userIds, s.UserID)
		}
	}

	users, err := r.DbQuery.GetUsersByIds(ctx, userIds)
	if err != nil {
		return nil, err
	}
	if len(users) != len(userIds) {
		return nil, errorhelper.NewAppError(UserDoesNotExist, Messages[UserDoesNotExist], nil)
	}

	payersMap := make(map[int64][]db.ExpensePayer)
	for _, p := range payers {
		payersMap[p.ExpenseID] = append(payersMap[p.ExpenseID], p)
	}

	sharesMap := make(map[int64][]db.ExpenseShare)
	for _, s := range shares {
		sharesMap[s.ExpenseID] = append(sharesMap[s.ExpenseID], s)
	}

	currencyMap := make(map[int64]db.Currency)
	for _, currency := range currencies {
		currencyMap[currency.ID] = currency
	}

	userMap := make(map[int64]db.User)
	for _, user := range users {
		userMap[user.ID] = user
	}

	response := &model.ExpenseSummary{
		Expenses: make([]*model.Expense, 0),
		Owes:     make([]*model.Owe, 0),
		Owed:     make([]*model.Owe, 0),
	}
	for _, expense := range expenses {
		expenseModel := &model.Expense{
			ID:          expense.ID,
			Type:        expenseTypeString(expense.Type),
			Name:        expense.Name,
			Description: expense.Description,
			Amount:      pghelper.Decimal(expense.Amount),
			Currency:    toCurrencyModel(currencyMap[expense.CurrencyID]),
			ExpenseAt:   expense.ExpenseAt.Time,
			Payers:      make([]*model.Share, 0),
			Shares:      make([]*model.Share, 0),
		}

		for _, payer := range payersMap[expense.ID] {
			expenseModel.Payers = append(expenseModel.Payers, &model.Share{
				User:   toUserModel(userMap[payer.UserID]),
				Amount: pghelper.Decimal(payer.Amount),
			})
		}

		for _, share := range sharesMap[expense.ID] {
			expenseModel.Shares = append(expenseModel.Shares, &model.Share{
				User:   toUserModel(userMap[share.UserID]),
				Amount: pghelper.Decimal(share.Amount),
			})
		}

		response.Expenses = append(response.Expenses, expenseModel)
	}

	// Positive means user has paid the amount
	// Negative means user owes the amount
	// SGD
	// alice, bob, charlie
	// Expense 1
	// 3    , 0  , 0
	// -1   , -1 , -1

	// Expense 2
	// 2    , 7  , 0
	// -3   , -3 , -3

	// total
	// 1   , 3  , -4
	// alice is owed 1
	// bob is owed 3
	// charlie owes 4

	balances := make(map[int64]map[int64]decimal.Decimal) // currencyID -> userID -> balance
	for _, expense := range response.Expenses {
		currencyID := expense.Currency.ID
		if _, ok := balances[currencyID]; !ok {
			balances[currencyID] = make(map[int64]decimal.Decimal)
		}
		for _, payer := range expense.Payers {
			balances[currencyID][payer.User.ID] = balances[currencyID][payer.User.ID].Add(payer.Amount)
		}
		for _, share := range expense.Shares {
			balances[currencyID][share.User.ID] = balances[currencyID][share.User.ID].Sub(share.Amount)
		}
	}

	// Use a greedy algorithm to calculate owed amounts
	// Match users who are owed the most money with users who owe the most money iteratively
	sortedCurrencyIDs := make([]int64, 0, len(balances))
	for currencyID := range balances {
		sortedCurrencyIDs = append(sortedCurrencyIDs, currencyID)
	}
	slices.Sort(sortedCurrencyIDs)

	for _, currencyID := range sortedCurrencyIDs {
		userBalances := balances[currencyID]
		creditors := make([]balance, 0)
		debtors := make([]balance, 0)

		for userID, amount := range userBalances {
			if amount.GreaterThan(decimal.Zero) {
				creditors = append(creditors, balance{userID, amount})
			} else if amount.LessThan(decimal.Zero) {
				debtors = append(debtors, balance{userID, amount.Neg()})
			}
		}

		slices.SortFunc(creditors, sortBalanceDesc)
		slices.SortFunc(debtors, sortBalanceAsc)

		i, j := 0, 0
		for i < len(creditors) && j < len(debtors) {
			creditor := &creditors[i]
			debtor := &debtors[j]

			amountOwed := decimal.Min(creditor.Amount, debtor.Amount)

			if debtor.UserID == userId {
				response.Owes = append(response.Owes, &model.Owe{
					User:     toUserModel(userMap[creditor.UserID]),
					Amount:   amountOwed,
					Currency: toCurrencyModel(currencyMap[currencyID]),
				})
			}

			if creditor.UserID == userId {
				response.Owed = append(response.Owed, &model.Owe{
					User:     toUserModel(userMap[debtor.UserID]),
					Amount:   amountOwed,
					Currency: toCurrencyModel(currencyMap[currencyID]),
				})
			}

			creditor.Amount = creditor.Amount.Sub(amountOwed)
			debtor.Amount = debtor.Amount.Sub(amountOwed)

			if creditor.Amount.Equal(decimal.Zero) {
				i++
			}
			if debtor.Amount.Equal(decimal.Zero) {
				j++
			}
		}
	}

	return response, nil
}

// Currencies is the resolver for the currencies field.
func (r *queryResolver) Currencies(ctx context.Context) ([]*model.Currency, error) {
	currencies, err := r.DbQuery.GetCurrencies(ctx)
	if err != nil {
		return nil, err
	}

	response := make([]*model.Currency, 0)
	for _, currency := range currencies {
		response = append(response, toCurrencyModel(currency))
	}

	return response, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
