package graphql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"errors"
	"slices"
	"strconv"

	pgx "github.com/jackc/pgx/v5"
	"github.com/raythx98/go-dutch/graphql/model"
	"github.com/raythx98/go-dutch/sqlc/db"
	"github.com/raythx98/go-dutch/tools/pghelper"
	"github.com/raythx98/gohelpme/errorhelper"
	"github.com/raythx98/gohelpme/tool/logger"
	"github.com/raythx98/gohelpme/tool/reqctx"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, email string, password string, username string) (*model.User, error) {
	_, err := r.DbQuery.GetUserByEmail(ctx, email)
	if err == nil {
		return nil, errorhelper.NewAppError(1, "Email has already been registered", err)
	}
	if !errors.Is(err, pgx.ErrNoRows) {
		return nil, err
	}

	encodedHashedPassword, err := r.Crypto.GenerateFromPassword(password)
	if err != nil {
		return nil, err
	}

	user, err := r.DbQuery.CreateUser(ctx, db.CreateUserParams{
		Username: username,
		Email:    email,
		Password: encodedHashedPassword,
	})
	if err != nil {
		return nil, err
	}

	accessToken, err := r.Jwt.NewAccessToken(strconv.FormatInt(user.ID, 10))
	if err != nil {
		return nil, err
	}

	return &model.User{
		ID:    user.ID,
		Name:  user.Username,
		Token: accessToken,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.User, error) {
	user, err := r.DbQuery.GetUserByEmail(ctx, email)
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, errorhelper.NewAppError(2, "Email is not registered", err)
	}
	if err != nil {
		return nil, err
	}

	authenticated, err := r.Crypto.ComparePasswordAndHash(password, user.Password)
	if err != nil {
		return nil, err
	}

	if !authenticated {
		return nil, errorhelper.NewAppError(3, "Incorrect Password", err)
	}

	accessToken, err := r.Jwt.NewAccessToken(strconv.FormatInt(user.ID, 10))
	if err != nil {
		return nil, err
	}

	return &model.User{
		ID:    user.ID,
		Name:  user.Username,
		Token: accessToken,
	}, nil
}

// AddGroup is the resolver for the addGroup field.
func (r *mutationResolver) AddGroup(ctx context.Context, name string) (*model.Group, error) {
	tx, err := r.Db.Pool().Begin(ctx)
	if err != nil {
		return nil, err
	}

	defer func(tx pgx.Tx, ctx context.Context) {
		if err := tx.Rollback(ctx); err != nil {
			r.Log.Error(ctx, "failed to rollback transaction", logger.WithError(err))
		}
	}(tx, ctx)

	qtx := r.DbQuery.WithTx(tx)

	group, err := qtx.CreateGroup(ctx, name)
	if err != nil {
		return nil, err
	}

	err = qtx.AddUserToGroup(ctx, db.AddUserToGroupParams{
		UserID:  *reqctx.GetValue(ctx).UserId,
		GroupID: group.ID,
	})
	if err != nil {
		return nil, err
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, err
	}

	response := &model.Group{
		ID:      group.ID,
		Name:    group.Name,
		Members: make([]*model.User, 0),
	}

	members, err := qtx.GetGroupMembers(ctx, group.ID)
	if err == nil {
		for _, member := range members {
			response.Members = append(response.Members, &model.User{
				ID:   member.ID,
				Name: member.Username,
			})
		}
	}

	return response, nil
}

// AddMember is the resolver for the addMember field.
func (r *mutationResolver) AddMember(ctx context.Context, groupID int64, email string) (*model.Group, error) {
	userId := *reqctx.GetValue(ctx).UserId

	group, err := r.DbQuery.GetGroup(ctx, groupID)
	if err != nil {
		return nil, err
	}

	members, err := r.DbQuery.GetGroupMembers(ctx, groupID)
	if err != nil {
		return nil, err
	}

	if !slices.ContainsFunc(members, func(n db.User) bool { return n.ID == userId }) {
		return nil, errorhelper.NewAppError(4, "You are not an existing group member", nil)
	}

	user, err := r.DbQuery.GetUserByEmail(ctx, email)
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, errorhelper.NewAppError(5, "User does not exist", err)
	}
	if err != nil {
		return nil, err
	}

	err = r.DbQuery.AddUserToGroup(ctx, db.AddUserToGroupParams{
		UserID:  user.ID,
		GroupID: groupID,
	})
	if err != nil {
		return nil, err
	}

	response := &model.Group{
		ID:      groupID,
		Name:    group.Name,
		Members: make([]*model.User, 0),
	}

	for _, member := range members {
		response.Members = append(response.Members, &model.User{
			ID:   member.ID,
			Name: member.Username,
		})
	}
	response.Members = append(response.Members, &model.User{
		ID:   user.ID,
		Name: user.Username,
	})

	return response, nil
}

// AddExpense is the resolver for the addExpense field.
func (r *mutationResolver) AddExpense(ctx context.Context, groupID int64, input model.ExpenseInput) (*model.Expense, error) {
	userId := *reqctx.GetValue(ctx).UserId

	members, err := r.DbQuery.GetGroupMembers(ctx, groupID)
	if err != nil {
		return nil, err
	}

	if !slices.ContainsFunc(members, func(n db.User) bool { return n.ID == userId }) {
		return nil, errorhelper.NewAppError(4, "You are not an existing group member", nil)
	}

	currencies, err := r.DbQuery.GetCurrenciesByIds(ctx, []int64{input.CurrencyID})
	if err != nil {
		return nil, err
	}
	if len(currencies) == 0 {
		return nil, errorhelper.NewAppError(6, "Currency does not exist", nil)
	}

	userIds := make([]int64, 0)
	for _, payer := range input.Payers {
		if !slices.Contains(userIds, payer.UserID) {
			userIds = append(userIds, payer.UserID)
		}
	}
	for _, share := range input.Shares {
		if !slices.Contains(userIds, share.UserID) {
			userIds = append(userIds, share.UserID)
		}
	}

	users, err := r.DbQuery.GetUsersByIds(ctx, userIds)
	if err != nil {
		return nil, err
	}

	usersMap := make(map[int64]db.User)
	for _, user := range users {
		usersMap[user.ID] = user
	}

	tx, err := r.Db.Pool().Begin(ctx)
	if err != nil {
		return nil, err
	}

	defer func(tx pgx.Tx, ctx context.Context) {
		if err := tx.Rollback(ctx); err != nil {
			r.Log.Error(ctx, "failed to rollback transaction", logger.WithError(err))
		}
	}(tx, ctx)

	qtx := r.DbQuery.WithTx(tx)

	expense, err := qtx.CreateExpense(ctx, db.CreateExpenseParams{
		GroupID:    groupID,
		Amount:     input.Amount,
		CurrencyID: input.CurrencyID,
		ExpenseAt:  pghelper.Time(&input.ExpenseAt),
	})
	if err != nil {
		return nil, err
	}

	response := &model.Expense{
		ID:     expense.ID,
		Amount: expense.Amount,
		Currency: &model.Currency{
			ID:     currencies[0].ID,
			Code:   currencies[0].Code,
			Name:   currencies[0].Name,
			Symbol: currencies[0].Symbol,
		},
		ExpenseAt: expense.ExpenseAt.Time,
		Payers:    make([]*model.Share, 0),
		Shares:    make([]*model.Share, 0),
	}

	for _, payer := range input.Payers {
		expensePayer, err := qtx.CreateExpensePayer(ctx, db.CreateExpensePayerParams{
			ExpenseID: expense.ID,
			UserID:    payer.UserID,
			Amount:    payer.Amount,
		})
		if err != nil {
			return nil, err
		}

		response.Payers = append(response.Payers, &model.Share{
			User: &model.User{
				ID:   expensePayer.UserID,
				Name: usersMap[expensePayer.UserID].Username,
			},
			Amount: expensePayer.Amount,
		})
	}

	for _, share := range input.Shares {
		expenseSharer, err := qtx.CreateExpenseShare(ctx, db.CreateExpenseShareParams{
			ExpenseID: expense.ID,
			UserID:    share.UserID,
			Amount:    share.Amount,
		})
		if err != nil {
			return nil, err
		}

		response.Shares = append(response.Shares, &model.Share{
			User: &model.User{
				ID:   expenseSharer.UserID,
				Name: usersMap[expenseSharer.UserID].Username,
			},
			Amount: expenseSharer.Amount,
		})
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, err
	}

	return response, nil
}

// EditExpense is the resolver for the editExpense field.
func (r *mutationResolver) EditExpense(ctx context.Context, expenseID int64, input model.ExpenseInput) (*model.Expense, error) {
	userId := *reqctx.GetValue(ctx).UserId

	existingExpense, err := r.DbQuery.GetExpense(ctx, expenseID)
	if err != nil {
		return nil, err
	}

	members, err := r.DbQuery.GetGroupMembers(ctx, existingExpense.GroupID)
	if err != nil {
		return nil, err
	}

	if !slices.ContainsFunc(members, func(n db.User) bool { return n.ID == userId }) {
		return nil, errorhelper.NewAppError(4, "You are not an existing group member", nil)
	}

	currencies, err := r.DbQuery.GetCurrenciesByIds(ctx, []int64{input.CurrencyID})
	if err != nil {
		return nil, err
	}
	if len(currencies) == 0 {
		return nil, errorhelper.NewAppError(6, "Currency does not exist", nil)
	}

	userIds := make([]int64, 0)
	for _, payer := range input.Payers {
		if !slices.Contains(userIds, payer.UserID) {
			userIds = append(userIds, payer.UserID)
		}
	}
	for _, share := range input.Shares {
		if !slices.Contains(userIds, share.UserID) {
			userIds = append(userIds, share.UserID)
		}
	}

	users, err := r.DbQuery.GetUsersByIds(ctx, userIds)
	if err != nil {
		return nil, err
	}

	usersMap := make(map[int64]db.User)
	for _, user := range users {
		usersMap[user.ID] = user
	}

	tx, err := r.Db.Pool().Begin(ctx)
	if err != nil {
		return nil, err
	}

	defer func(tx pgx.Tx, ctx context.Context) {
		if err := tx.Rollback(ctx); err != nil {
			r.Log.Error(ctx, "failed to rollback transaction", logger.WithError(err))
		}
	}(tx, ctx)

	qtx := r.DbQuery.WithTx(tx)

	expense, err := qtx.CreateExpense(ctx, db.CreateExpenseParams{
		GroupID:    existingExpense.GroupID,
		Amount:     input.Amount,
		CurrencyID: input.CurrencyID,
		ExpenseAt:  pghelper.Time(&input.ExpenseAt),
	})
	if err != nil {
		return nil, err
	}

	response := &model.Expense{
		ID:     expense.ID,
		Amount: expense.Amount,
		Currency: &model.Currency{
			ID:     currencies[0].ID,
			Code:   currencies[0].Code,
			Name:   currencies[0].Name,
			Symbol: currencies[0].Symbol,
		},
		ExpenseAt: expense.ExpenseAt.Time,
		Payers:    make([]*model.Share, 0),
		Shares:    make([]*model.Share, 0),
	}

	for _, payer := range input.Payers {
		expensePayer, err := qtx.CreateExpensePayer(ctx, db.CreateExpensePayerParams{
			ExpenseID: expense.ID,
			UserID:    payer.UserID,
			Amount:    payer.Amount,
		})
		if err != nil {
			return nil, err
		}

		response.Payers = append(response.Payers, &model.Share{
			User: &model.User{
				ID:   expensePayer.UserID,
				Name: usersMap[expensePayer.UserID].Username,
			},
			Amount: expensePayer.Amount,
		})
	}

	for _, share := range input.Shares {
		expenseSharer, err := qtx.CreateExpenseShare(ctx, db.CreateExpenseShareParams{
			ExpenseID: expense.ID,
			UserID:    share.UserID,
			Amount:    share.Amount,
		})
		if err != nil {
			return nil, err
		}

		response.Shares = append(response.Shares, &model.Share{
			User: &model.User{
				ID:   expenseSharer.UserID,
				Name: usersMap[expenseSharer.UserID].Username,
			},
			Amount: expenseSharer.Amount,
		})
	}

	if err := qtx.DeleteExpense(ctx, expenseID); err != nil {
		return nil, err
	}

	if err := tx.Commit(ctx); err != nil {
		return nil, err
	}

	return response, nil
}

// DeleteExpense is the resolver for the deleteExpense field.
func (r *mutationResolver) DeleteExpense(ctx context.Context, expenseID int64) (bool, error) {
	userId := *reqctx.GetValue(ctx).UserId

	expense, err := r.DbQuery.GetExpense(ctx, expenseID)
	if err != nil {
		return false, err
	}

	members, err := r.DbQuery.GetGroupMembers(ctx, expense.GroupID)
	if err != nil {
		return false, err
	}

	if !slices.ContainsFunc(members, func(n db.User) bool { return n.ID == userId }) {
		return false, errorhelper.NewAppError(4, "You are not an existing group member", nil)
	}

	if err := r.DbQuery.DeleteExpense(ctx, expenseID); err != nil {
		return false, err
	}

	return true, nil
}

// Groups is the resolver for the groups field.
func (r *queryResolver) Groups(ctx context.Context) ([]*model.Group, error) {
	userId := *reqctx.GetValue(ctx).UserId

	groups, err := r.DbQuery.GetGroupsByUser(ctx, userId)
	if err != nil {
		return nil, err
	}

	response := make([]*model.Group, 0)
	for _, group := range groups {
		members, err := r.DbQuery.GetGroupMembers(ctx, group.ID)
		if err != nil {
			return nil, err
		}

		memberModels := make([]*model.User, 0)
		for _, member := range members {
			memberModels = append(memberModels, &model.User{
				ID:   member.ID,
				Name: member.Username,
			})
		}

		response = append(response, &model.Group{
			ID:      group.ID,
			Name:    group.Name,
			Members: memberModels,
		})
	}

	return response, nil
}

// Expenses is the resolver for the expenses field.
func (r *queryResolver) Expenses(ctx context.Context, groupID int64) (*model.ExpenseSummary, error) {
	userId := *reqctx.GetValue(ctx).UserId

	members, err := r.DbQuery.GetGroupMembers(ctx, groupID)
	if err != nil {
		return nil, err
	}

	if !slices.ContainsFunc(members, func(n db.User) bool { return n.ID == userId }) {
		return nil, errorhelper.NewAppError(4, "You are not an existing group member", nil)
	}

	expenses, err := r.DbQuery.GetExpenses(ctx, groupID)
	if err != nil {
		return nil, err
	}

	expenseIds := make([]int64, 0)
	currencyIds := make([]int64, 0)
	userIds := make([]int64, 0)
	for _, expense := range expenses {
		expenseIds = append(expenseIds, expense.ID)
		if !slices.Contains(currencyIds, expense.CurrencyID) {
			currencyIds = append(currencyIds, expense.CurrencyID)
		}
		if !slices.Contains(userIds, userId) {
			userIds = append(userIds, userId)
		}
	}

	payers, err := r.DbQuery.GetExpensesPayers(ctx, expenseIds)
	if err != nil {
		return nil, err
	}

	shares, err := r.DbQuery.GetExpensesShares(ctx, expenseIds)
	if err != nil {
		return nil, err
	}

	currencies, err := r.DbQuery.GetCurrenciesByIds(ctx, currencyIds)
	if err != nil {
		return nil, err
	}

	users, err := r.DbQuery.GetUsersByIds(ctx, userIds)
	if err != nil {
		return nil, err
	}

	payersMap := make(map[int64][]db.ExpensePayer)
	for _, p := range payers {
		payersMap[p.ExpenseID] = append(payersMap[p.ExpenseID], p)
	}

	sharesMap := make(map[int64][]db.ExpenseShare)
	for _, s := range shares {
		sharesMap[s.ExpenseID] = append(sharesMap[s.ExpenseID], s)
	}

	currencyMap := make(map[int64]db.Currency)
	for _, currency := range currencies {
		currencyMap[currency.ID] = currency
	}

	userMap := make(map[int64]db.User)
	for _, user := range users {
		userMap[user.ID] = user
	}

	response := &model.ExpenseSummary{
		Expenses: make([]*model.Expense, 0),
		Owes:     make([]*model.OweDetail, 0),
		Owed:     make([]*model.OweDetail, 0),
	}
	for _, expense := range expenses {
		expenseModel := &model.Expense{
			ID:     expense.ID,
			Amount: expense.Amount,
			Currency: &model.Currency{
				ID:     currencyMap[expense.CurrencyID].ID,
				Code:   currencyMap[expense.CurrencyID].Code,
				Name:   currencyMap[expense.CurrencyID].Name,
				Symbol: currencyMap[expense.CurrencyID].Symbol,
			},
			ExpenseAt: expense.ExpenseAt.Time,
			Payers:    make([]*model.Share, 0),
			Shares:    make([]*model.Share, 0),
		}

		for _, payer := range payersMap[expense.ID] {
			expenseModel.Payers = append(expenseModel.Payers, &model.Share{
				User: &model.User{
					ID:   payer.UserID,
					Name: userMap[payer.UserID].Username,
				},
				Amount: payer.Amount,
			})
		}

		for _, share := range sharesMap[expense.ID] {
			expenseModel.Shares = append(expenseModel.Shares, &model.Share{
				User: &model.User{
					ID:   share.UserID,
					Name: userMap[share.UserID].Username,
				},
				Amount: share.Amount,
			})
		}

		response.Expenses = append(response.Expenses, expenseModel)
	}

	// TODO: Calculate Owes and Owed

	return response, nil
}

// Currencies is the resolver for the currencies field.
func (r *queryResolver) Currencies(ctx context.Context) ([]*model.Currency, error) {
	currencies, err := r.DbQuery.GetCurrencies(ctx)
	if err != nil {
		return nil, err
	}

	response := make([]*model.Currency, 0)
	for _, currency := range currencies {
		response = append(response, &model.Currency{
			ID:     currency.ID,
			Code:   currency.Code,
			Name:   currency.Name,
			Symbol: currency.Symbol,
		})
	}

	return response, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
